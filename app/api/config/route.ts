import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { promises as fs } from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { loadConfig, ConfigLoadError } from '@/lib/config';

// Zod schema for configuration validation
const ConfigSchema = z.object({
  project_name: z.string().min(1, 'Project name is required'),
  output_folder: z.string().min(1, 'Output folder is required'),
  user_name: z.string().min(1, 'User name is required'),
  communication_language: z.string().min(1, 'Communication language is required'),
  llm: z.object({
    provider: z.enum(['gemini', 'claude', 'openai', 'local'], {
      message: 'Invalid LLM provider',
    }),
    apiKey: z.string().optional(),
    model: z.string().min(1, 'Model is required'),
  }),
  modules: z.object({
    mam: z.object({ enabled: z.boolean() }),
    mab: z.object({ enabled: z.boolean() }),
    cis: z.object({ enabled: z.boolean() }),
  }),
});

type Config = z.infer<typeof ConfigSchema>;

/**
 * POST /api/config
 * Save configuration to file system (config.yaml + .env)
 */
export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body = await request.json();

    // Validate configuration with Zod
    const validationResult = ConfigSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation failed',
          details: validationResult.error.flatten().fieldErrors,
        },
        { status: 400 }
      );
    }

    const config: Config = validationResult.data;

    // Determine config directory path
    // In Docker: /app/data/config
    // In local: ./madace-data/config
    const configDir = process.env.CONFIG_DIR || path.join(process.cwd(), 'madace-data', 'config');

    // Create config directory if it doesn't exist
    await fs.mkdir(configDir, { recursive: true });

    // Backup existing config.yaml if it exists
    const configPath = path.join(configDir, 'config.yaml');
    try {
      await fs.access(configPath);
      const backupPath = path.join(
        configDir,
        `config.backup.${new Date().toISOString().replace(/:/g, '-')}.yaml`
      );
      await fs.copyFile(configPath, backupPath);
    } catch {
      // File doesn't exist, no backup needed
    }

    // Generate config.yaml content
    const configYaml = {
      project_name: config.project_name,
      output_folder: config.output_folder,
      user_name: config.user_name,
      communication_language: config.communication_language,
      madace_version: '3.0.0-alpha',
      installed_at: new Date().toISOString(),
      modules: {
        mam: {
          enabled: config.modules.mam.enabled,
        },
        mab: {
          enabled: config.modules.mab.enabled,
        },
        cis: {
          enabled: config.modules.cis.enabled,
        },
      },
    };

    // Write config.yaml atomically (temp file + rename)
    const tempConfigPath = path.join(configDir, `config.tmp.${Date.now()}.yaml`);
    const yamlContent = yaml.dump(configYaml, {
      indent: 2,
      lineWidth: 120,
      noRefs: true,
    });
    await fs.writeFile(tempConfigPath, yamlContent, 'utf-8');
    await fs.rename(tempConfigPath, configPath);

    // Generate .env content
    const envLines: string[] = [
      '# MADACE Configuration',
      '# Generated by setup wizard',
      `# Date: ${new Date().toISOString()}`,
      '',
      '# LLM Configuration',
      `LLM_PROVIDER=${config.llm.provider}`,
    ];

    // Add provider-specific configuration
    switch (config.llm.provider) {
      case 'gemini':
        envLines.push(`GEMINI_API_KEY=${config.llm.apiKey || ''}`);
        envLines.push(`GEMINI_MODEL=${config.llm.model}`);
        break;
      case 'claude':
        envLines.push(`CLAUDE_API_KEY=${config.llm.apiKey || ''}`);
        envLines.push(`CLAUDE_MODEL=${config.llm.model}`);
        break;
      case 'openai':
        envLines.push(`OPENAI_API_KEY=${config.llm.apiKey || ''}`);
        envLines.push(`OPENAI_MODEL=${config.llm.model}`);
        break;
      case 'local':
        envLines.push(`LOCAL_MODEL_URL=${config.llm.apiKey || 'http://localhost:11434'}`);
        envLines.push(`LOCAL_MODEL=${config.llm.model}`);
        break;
    }

    envLines.push('');
    envLines.push('# Application Configuration');
    envLines.push('NODE_ENV=production');
    envLines.push(`CONFIG_DIR=${configDir}`);
    envLines.push('');

    // Backup existing .env if it exists
    const envPath = path.join(configDir, '.env');
    try {
      await fs.access(envPath);
      const backupPath = path.join(
        configDir,
        `.env.backup.${new Date().toISOString().replace(/:/g, '-')}`
      );
      await fs.copyFile(envPath, backupPath);
    } catch {
      // File doesn't exist, no backup needed
    }

    // Write .env atomically (temp file + rename)
    const tempEnvPath = path.join(configDir, `.env.tmp.${Date.now()}`);
    await fs.writeFile(tempEnvPath, envLines.join('\n'), 'utf-8');

    // Set restrictive permissions on .env (read/write for owner only)
    // Note: chmod is Unix-specific, but this is best practice for security
    try {
      await fs.chmod(tempEnvPath, 0o600);
    } catch {
      // Windows doesn't support chmod, ignore error
    }

    await fs.rename(tempEnvPath, envPath);

    // Return success response
    return NextResponse.json(
      {
        success: true,
        message: 'Configuration saved successfully',
        paths: {
          config: configPath,
          env: envPath,
        },
      },
      { status: 200 }
    );
  } catch (error) {
    console.error('Error saving configuration:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to save configuration',
        message: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/config
 * Load and validate configuration from file system
 */
export async function GET() {
  try {
    // Load and validate configuration using the new loader
    const config = await loadConfig();

    // Return validated configuration (without sensitive data)
    return NextResponse.json(
      {
        success: true,
        config,
      },
      { status: 200 }
    );
  } catch (error) {
    // Handle configuration loading errors
    if (error instanceof ConfigLoadError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Configuration error',
          message: error.message,
          path: error.configPath,
        },
        { status: 404 }
      );
    }

    // Handle unexpected errors
    console.error('Error loading configuration:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to load configuration',
        message: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
